import sys
import os

# call /bin/sh directly via os
# os.execv('/bin/sh', (' ',))
# sys.modules['os'].system('/bin/sh')

# execute code from other file
# exec(open('shell.py').read())
# way without exec (compiling)
"""
this way is not working
# local
def read():
    return open('./shell.py', 'r').read()
compiledCode = read.__code__.co_code

# remote
function_type = type(lambda: None)
code_type = type((lambda: None).__code__) # Get <type 'type'>
consts = (None, './shell.py', 'r')
bytecode = compiledCode
names = ('open', 'read')
# exec compiled code via eval/exec
eval(code_type(0, 0, 3, 64, bytecode, consts, names, (), 'noname', '<module>', 1, '', (), ()))
"""

# print(dir(__builtins__))
# get base class of an obj
# print ([].__class__.__bases__[0])
# print ([].__class__.__mro__[-1])

# get specific method of base class
# print([].__class__.__dict__['append'])
# add element to a via method of base class
a = []
[].__class__.__dict__['append'](a, 'firstEle')
# print(a)

# get subclasses of object (here the second last one)
# print([].__class__.__base__.__subclasses__()[-2])
# get functions of this base class and locate __init__
# print(dir([].__class__.__base__.__subclasses__()[-2]))
# print([].__class__.__base__.__subclasses__()[-2].__init__)
# print(dir([].__class__.__base__.__subclasses__()[-2].__init__))
# get properties of globals
# print([].__class__.__base__.__subclasses__()[-2].__init__.__getattribute__('__globals__'))

# add more elements
a.__getattribute__('append')('secondEle')
a.__class__.append(a, 'thirdEle')
# print(a)

# combine both methods
# test if init method is present
# print([].__class__.__dict__['__init__'])
# get access to init method
# print([].__class__.__getattribute__([], '__init__'))
print([].__class__.__base__.__subclasses__()[-2].__init__.__globals__['os'])