from libPySI import PySI
from plugins.standard_environment_library.SIEffect import SIEffect

# from pandas import Timestamp
# import numpy as np

class PythonCode(SIEffect):
    regiontype = PySI.EffectType.SI_CUSTOM
    regionname = PySI.EffectName.SI_STD_NAME_TAG
    region_display_name = 'PythonCode'

    def __init__(self, shape=PySI.PointVector(), uuid="", kwargs={}):
        super(PythonCode, self).__init__(shape, uuid, "res/tag.png", PythonCode.regiontype, 
                                PythonCode.regionname, kwargs)

        # specify which qml file to use
        self.qml_path = "plugins/standard_environment_library/tag/PythonCode.qml"
            
        # specify which color a region having the tag-effect should have
        self.color = PySI.Color(255, 0, 0, 255)

        # add and enable the code execution effect by specifying its capability and 
        # and assigning its collision event functions
        self.enable_effect("code_execution", SIEffect.EMISSION, self.on_tag_enter_emit,
                        self.on_tag_continuous_emit, self.on_tag_leave_emit)

        # this is the code that should be executed and lead to a segmentation fault
        """
        america_chicago = "dateutil//usr/share/zoneinfo/America/Chicago"
        transition_1 = Timestamp(year=2013, month=11, day=3, hour=1, minute=0, tz=america_chicago)
        transition_2 = Timestamp(year=2013, month=11, day=3, hour=1, minute=0, fold=1, tz=america_chicago)
        print(transition_1, transition_2)
        print(hash(transition_1))
        print(hash(transition_2))
        """


        # define the functions needed for collision events with the "code execution" capability
        
        # when another eligible effect first collides with this one, emit that the 
        # other one should be tagged (todo code executed)
        def on_tag_enter_emit(self, other):
            return True
        
        # it makes no sense to redundantly tag the other effect on every collision 
        # event, so we leave this blank 
        def on_tag_continuous_emit(self, other):
            pass
        
        # we want to keep the tag beyond collision, so we leave this also blank
        def on_tag_leave_emit(self, other):
            pass 