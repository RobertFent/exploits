import csv
import io
import math
import sys

# implementation of methods causing errors
# sorted after likelihood of occuring
# TheErrorLandscape

class ErrorExamples:
    
    def __init__(self) -> None:
        pass  

    # 10.02%
    def nameError(self):
        print(hello)

    # 8.92%
    def typeError1(self, string: str):
        print(string)

    def typeError2(string: str):
        print(string)

    # 4.46%
    def keyError(self, my_dict = {}, key = 'three'):
        print(my_dict[key])
    
    def keyErrorGuarded(self, my_dict = {}, key = 'three'):
        # if statement is guard
        if key in my_dict.keys():
            print(my_dict[key])
        else:
            print('prevented KeyError')

    # 4.49%
    def indexError(self, arr = []):
        print(arr[len(arr)])
    
    def indexErrorGuarded(self, arr = []):
        index = len(arr)
        if not (index >= 0 and index < len(arr)):
            print('prevented IndexError')
        else:
            print(arr[len(arr)])
    
    # 2.62%
    # probably renamed in ModuleNotFoundError
    def importError(self):
        import fail
    
    # 1.92%
    # append as example method
    def attributeError(self, object = 10, value = 5):
        object.append(value)
        print(object)
    
    # https://stackoverflow.com/questions/7580532/how-to-check-whether-a-method-exists-in-python
    def attributeErrorGuarded(self, object = 10, value = 5):
        if callable(getattr(object, 'append', None)):
            object.append(value)
            print(object)
        else:
            print('prevented AttributeError')

    # 1.31%
    # cant find this one yet
    def runtimeError(self):
        pass

    # 1.07%
    def unboundLocalError(self):
        print(msg)
        msg = 'Hello'
    
    # https://intellipaat.com/community/4504/how-do-i-check-if-a-variable-exists
    def unboundLocalErrorGuarded(self):
        if ('msg' in locals() or 'msg' in globals()):
            print(msg)
        else:
            print('prevented UnboundLocalError')
        msg = 'Hello'

    # 0.75%
    # too many cases to guard it
    def valueError(self):
        return int('string')

    # 0.20%
    def zeroDivisionError(self, dividend = 10, divisor = 0):
        return dividend/divisor

    def zeroDivisionErrorGuarded(self, dividend = 10, divisor = 0):
        if (divisor != 0):
            return dividend/divisor
        else:
            print('prevented ZeroDivisionError')

    # 0.05%
    def assertionError(self):
        x, y = 10, 5
        assert x == y

    # 0.01%
    def exception(self):
        raise Exception('Crash')

    # 0.00%
    # cant reproduce this one
    def memoryError(self):
        x = 2
        while True:
            x = x**10
            print(x)

    # 0.00%
    # https://stackoverflow.com/questions/48180209/stop-iteration-error-when-using-next
    def stopIteration(self):
        a = (i ** 2 for i in range(5)) # a is generator obj
        list(a) # calling list will exhaust the generator
        next(a) # calling next on exhausted generator obj raises StopIteration
        # next(a, None) would prevent this error

    def recursionError(self):
        return self.recursionError()

    def overflowError(self):
        print(math.exp(1000))

    """
    def indentationError(self):
    print('error')
    """

def unprotected_errors():
    # NameError: name 'hello' is not defined
    errorExamples.nameError()

    # TypeError: typeError1() missing 1 required positional argument: 'string'
    errorExamples.typeError1()

    # TypeError: typeError2() takes 1 positional argument but 2 were given
    errorExamples.typeError2('foo')

    # KeyError: 'three'
    errorExamples.keyError()

    # IndexError: list index out of range
    errorExamples.indexError()

    # UnboundLocalError: local variable 'msg' referenced before assignment
    errorExamples.unboundLocalError()

    # ModuleNotFoundError: No module named 'fail'
    errorExamples.importError()

    # AttributeError: 'int' object has no attribute 'append'
    errorExamples.attributeError()

    # ValueError: invalid literal for int() with base 10: 'string'
    errorExamples.valueError()

    # ZeroDivisionError: division by zero
    errorExamples.zeroDivisionError()

    # AssertionError
    errorExamples.assertionError()

    # Exception: Crash
    errorExamples.exception()

    # cant be reproduced for now
    errorExamples.memoryError()

    # StopIteration
    errorExamples.stopIteration()

    # RecursionError: maximum recursion depth exceeded
    errorExamples.recursionError()

    # IndentationError: expected an indented block
    errorExamples.indentationError()

    # OverflowError: math range error
    errorExamples.overflowError()

# containing errors which cannot be guarded (effectively)
def try_except():
    try:
        # NameError
        errorExamples.nameError()
        # TypeError
        errorExamples.typeError1()
        errorExamples.typeError2()
        # ImportError
        errorExamples.importError()
        # ValueError
        errorExamples.valueError()
        # AssertionError
        errorExamples.assertionError()
        # Exception
        errorExamples.exception()
        # StopIteration
        errorExamples.stopIteration()
        # RecursionError
        errorExamples.recursionError()
        # OverflowError
        errorExamples.overflowError()

        # indentationError is not catchable
        # errorExamples.indentationError()
    
    except Exception as ex:
        print('Exception caught!')
        print(type(ex).__name__)
        print(ex.args)
    else:
        print('Could not catch any error')
    finally:
        print('try-excepting done') 

# containing errors which can be guarded
def code_guarding():
    # KeyError
    errorExamples.keyErrorGuarded()
    # IndexError
    errorExamples.indexErrorGuarded()
    # AttributeError
    errorExamples.attributeErrorGuarded()
    # UnboundLocalError
    errorExamples.unboundLocalErrorGuarded()
    # ZeroDivisionError
    errorExamples.zeroDivisionErrorGuarded()

    print('guarding done')

def my_except_hook(exctype, value, traceback):
    print(exctype)
    print(value)
    print(traceback)

"""
Fatal Python error: _Py_CheckRecursiveCall: Cannot recover from stack overflow.
Python runtime state: initialized

Current thread 0x00007f7be8546740 (most recent call first):
  [...]
  File "/home/robert/repos/exploits/runtime_errors/ErrorExamples.py", line 245 in crash
  ...
[1]    3494 abort      python ErrorExamples.py
"""
def crash():
    try:
        crash()
    except:
        crash()

def typeIndexGuardCombined():
    arr = ['a', 'b', 'c']
    index = len(arr)
    if not type(arr is list):
        print('prevented TypeError')
    if not (index >= 0 and index < len(arr)):
        print('prevented IndexError')
    else:
        print(arr[len(arr)])

if __name__ == '__main__':
    sys.excepthook = my_except_hook
    errorExamples = ErrorExamples()
    # crash()
    # unprotected_errors()
    # try_except()
    typeIndexGuardCombined()
    code_guarding()
    print('script done without crashing!')